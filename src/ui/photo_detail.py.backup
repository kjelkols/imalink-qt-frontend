"""
Photo detail view dialog - Simplified for viewing only
"""

from PySide6.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QLabel,
                               QPushButton)
from PySide6.QtCore import Qt, QThread, Signal
from PySide6.QtGui import QPixmap

from ..api.client import ImaLinkClient
from ..api.models import Photo


class PhotoDetailDialog(QDialog):
    """Dialog for viewing photos (full screen, no metadata editing)"""
    
    def __init__(self, photo: Photo, api_client: ImaLinkClient, parent=None):
        super().__init__(parent)
        self.photo = photo
        self.api_client = api_client
        self.thumbnail_pixmap = None
        self.original_pixmap = None
        self.zoom_level = 1.0
        self.current_preview_type = None
        
        self.init_ui()
        self.load_photo_data()
    
    def resizeEvent(self, event):
        """Handle window resize - update preview display"""
        super().resizeEvent(event)
        if self.zoom_level == 1.0:  # Only auto-resize when in fit-to-window mode
            self.display_preview()
    
    def keyPressEvent(self, event):
        """Handle keyboard shortcuts"""
        if event.key() == Qt.Key_Escape:
            self.close()
        elif event.key() == Qt.Key_Plus or event.key() == Qt.Key_Equal:
            self.zoom_in()
        elif event.key() == Qt.Key_Minus:
            self.zoom_out()
        elif event.key() == Qt.Key_0:
            self.zoom_reset()
        else:
            super().keyPressEvent(event)
    
    def init_ui(self):
        """Initialize the user interface - maximized photo view"""
        filename = self.photo.primary_filename or self.photo.hothash[:12]
        self.setWindowTitle(f"Photo Viewer - {filename}")
        self.setModal(False)
        
        # Start maximized
        self.showMaximized()
        
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(5)
        
        # Photo preview (full screen)
        self.thumbnail_label = QLabel()
        self.thumbnail_label.setAlignment(Qt.AlignCenter)
        self.thumbnail_label.setStyleSheet("QLabel { background-color: #000; }")
        self.thumbnail_label.setText("Loading preview...")
        self.thumbnail_label.setScaledContents(False)
        layout.addWidget(self.thumbnail_label, stretch=1)
        
        # Bottom toolbar
        toolbar_layout = QHBoxLayout()
        toolbar_layout.setContentsMargins(10, 5, 10, 5)
        
        # Zoom controls
        self.zoom_out_btn = QPushButton("‚ûñ")
        self.zoom_out_btn.setFixedSize(40, 30)
        self.zoom_label = QLabel("100%")
        self.zoom_label.setMinimumWidth(60)
        self.zoom_label.setAlignment(Qt.AlignCenter)
        self.zoom_in_btn = QPushButton("‚ûï")
        self.zoom_in_btn.setFixedSize(40, 30)
        self.zoom_reset_btn = QPushButton("Fit")
        self.zoom_reset_btn.setFixedWidth(50)
        
        self.zoom_out_btn.clicked.connect(self.zoom_out)
        self.zoom_reset_btn.clicked.connect(self.zoom_reset)
        self.zoom_in_btn.clicked.connect(self.zoom_in)
        
        toolbar_layout.addWidget(self.zoom_out_btn)
        toolbar_layout.addWidget(self.zoom_label)
        toolbar_layout.addWidget(self.zoom_in_btn)
        toolbar_layout.addWidget(self.zoom_reset_btn)
        toolbar_layout.addSpacing(20)
        
        # Status label
        self.preview_status_label = QLabel("Ready")
        self.preview_status_label.setStyleSheet("color: #ccc; font-style: italic;")
        toolbar_layout.addWidget(self.preview_status_label)
        toolbar_layout.addStretch()
        
        # Close button
        close_btn = QPushButton("Close [Esc]")
        close_btn.clicked.connect(self.close)
        toolbar_layout.addWidget(close_btn)
        
        layout.addLayout(toolbar_layout)
    
    def load_photo_data(self):
        """Load photo preview - always try coldpreview first, fallback to hotpreview"""
        self.load_preview('coldpreview')
        
        # Photo preview with scrollable zoom
        self.thumbnail_label = QLabel()
        self.thumbnail_label.setAlignment(Qt.AlignCenter)
        self.thumbnail_label.setMinimumSize(400, 400)
        self.thumbnail_label.setStyleSheet(
            "QLabel { border: 1px solid gray; background-color: #f0f0f0; }"
        )
        self.thumbnail_label.setText("Loading preview...")
        self.thumbnail_label.setScaledContents(False)  # We handle scaling ourselves
        preview_layout.addWidget(self.thumbnail_label, stretch=1)
        
        # Zoom controls
        zoom_layout = QHBoxLayout()
        self.zoom_out_btn = QPushButton("‚ûñ Zoom Out")
        self.zoom_reset_btn = QPushButton("ÔøΩ Fit to Window")
        self.zoom_in_btn = QPushButton("‚ûï Zoom In")
        self.zoom_label = QLabel("100%")
        self.zoom_label.setMinimumWidth(60)
        self.zoom_label.setAlignment(Qt.AlignCenter)
        
        self.zoom_out_btn.clicked.connect(self.zoom_out)
        self.zoom_reset_btn.clicked.connect(self.zoom_reset)
        self.zoom_in_btn.clicked.connect(self.zoom_in)
        
        zoom_layout.addWidget(self.zoom_out_btn)
        zoom_layout.addWidget(self.zoom_label)
        zoom_layout.addWidget(self.zoom_in_btn)
        zoom_layout.addWidget(self.zoom_reset_btn)
        zoom_layout.addStretch()
        preview_layout.addLayout(zoom_layout)
        
        # Status label for loading feedback
        self.preview_status_label = QLabel("Ready")
        self.preview_status_label.setAlignment(Qt.AlignCenter)
        self.preview_status_label.setStyleSheet("color: #666; font-style: italic;")
        preview_layout.addWidget(self.preview_status_label)
        
        # Basic info
        info_layout = QGridLayout()
        
        info_layout.addWidget(QLabel("Hothash:"), 0, 0)
        hothash_label = QLabel(self.photo.hothash)
        hothash_label.setTextInteractionFlags(Qt.TextSelectableByMouse)
        font = QFont()
        font.setFamily("monospace")
        hothash_label.setFont(font)
        info_layout.addWidget(hothash_label, 0, 1)
        
        row = 1
        
        # Handle missing ID field gracefully
        if hasattr(self.photo, 'id') and self.photo.id is not None:
            info_layout.addWidget(QLabel("ID:"), row, 0)
            info_layout.addWidget(QLabel(str(self.photo.id)), row, 1)
            row += 1
        
        # Date taken (from EXIF)
        if self.photo.taken_at:
            info_layout.addWidget(QLabel("üìÖ Date Taken:"), row, 0)
            # Format the date nicely
            try:
                from datetime import datetime
                dt = datetime.fromisoformat(self.photo.taken_at.replace('Z', '+00:00'))
                formatted_date = dt.strftime("%Y-%m-%d %H:%M:%S")
            except:
                formatted_date = self.photo.taken_at
            info_layout.addWidget(QLabel(formatted_date), row, 1)
            row += 1
        
        # GPS information
        if self.photo.has_gps and self.photo.gps_latitude and self.photo.gps_longitude:
            info_layout.addWidget(QLabel("üåç GPS Location:"), row, 0)
            lat = self.photo.gps_latitude
            lon = self.photo.gps_longitude
            gps_text = f"{lat:.6f}, {lon:.6f}"
            
            # Create a clickable GPS label
            gps_label = QLabel(f'<a href="https://www.google.com/maps?q={lat},{lon}">{gps_text}</a>')
            gps_label.setTextInteractionFlags(Qt.TextBrowserInteraction)
            gps_label.setOpenExternalLinks(True)
            info_layout.addWidget(gps_label, row, 1)
            row += 1
        elif self.photo.has_gps:
            info_layout.addWidget(QLabel("üåç GPS:"), row, 0)
            info_layout.addWidget(QLabel("Location available (coordinates missing)"), row, 1)
            row += 1
        
        # Image dimensions
        if self.photo.width and self.photo.height:
            info_layout.addWidget(QLabel("üìê Dimensions:"), row, 0)
            info_layout.addWidget(QLabel(f"{self.photo.width} √ó {self.photo.height} pixels"), row, 1)
            row += 1
        
        # Primary filename
        if self.photo.primary_filename:
            info_layout.addWidget(QLabel("üìÑ Primary File:"), row, 0)
            filename_label = QLabel(self.photo.primary_filename)
            filename_label.setTextInteractionFlags(Qt.TextSelectableByMouse)
            info_layout.addWidget(filename_label, row, 1)
            row += 1
        
        # File count
        if self.photo.files:
            info_layout.addWidget(QLabel("üìÅ File Count:"), row, 0)
            file_count_text = f"{len(self.photo.files)} file(s)"
            if self.photo.has_raw_companion:
                file_count_text += " (includes RAW)"
            info_layout.addWidget(QLabel(file_count_text), row, 1)
            row += 1
        
        # Import session
        if self.photo.import_session_id:
            info_layout.addWidget(QLabel("üì¶ Import Session:"), row, 0)
            info_layout.addWidget(QLabel(str(self.photo.import_session_id)), row, 1)
            row += 1
        
        info_layout.addWidget(QLabel("üïí Created:"), row, 0)
        info_layout.addWidget(QLabel(self.photo.created_at), row, 1)
        row += 1
        
        info_layout.addWidget(QLabel("üïí Updated:"), row, 0)
        info_layout.addWidget(QLabel(self.photo.updated_at), row, 1)
        
        preview_layout.addLayout(info_layout)
        parent_layout.addWidget(preview_group)
    
    def setup_metadata_section(self, parent_layout):
        """Setup metadata editing section"""
        metadata_group = QGroupBox("Metadata")
        metadata_layout = QGridLayout(metadata_group)
        
        # Title
        metadata_layout.addWidget(QLabel("Title:"), 0, 0)
        self.title_input = QLineEdit()
        self.title_input.setText(self.photo.title or "")
        metadata_layout.addWidget(self.title_input, 0, 1)
        
        # Description
        metadata_layout.addWidget(QLabel("Description:"), 1, 0)
        self.description_input = QTextEdit()
        self.description_input.setMaximumHeight(100)
        self.description_input.setText(self.photo.description or "")
        metadata_layout.addWidget(self.description_input, 1, 1)
        
        # Rating
        metadata_layout.addWidget(QLabel("Rating:"), 2, 0)
        self.rating_input = QSpinBox()
        self.rating_input.setRange(0, 5)
        self.rating_input.setValue(self.photo.rating or 0)
        metadata_layout.addWidget(self.rating_input, 2, 1)
        
        # Location
        metadata_layout.addWidget(QLabel("Location:"), 3, 0)
        self.location_input = QLineEdit()
        self.location_input.setText(self.photo.location or "")
        metadata_layout.addWidget(self.location_input, 3, 1)
        
        # Author info (read-only)
        if self.photo.author_id:
            metadata_layout.addWidget(QLabel("Author ID:"), 4, 0)
            metadata_layout.addWidget(QLabel(str(self.photo.author_id)), 4, 1)
        
        parent_layout.addWidget(metadata_group)
    
    def setup_tags_section(self, parent_layout):
        """Setup tags editing section"""
        tags_group = QGroupBox("Tags")
        tags_layout = QVBoxLayout(tags_group)
        
        # Current tags display
        current_tags_label = QLabel("Current tags:")
        tags_layout.addWidget(current_tags_label)
        
        self.current_tags_display = QLabel()
        self.current_tags_display.setWordWrap(True)
        self.current_tags_display.setStyleSheet(
            "QLabel { padding: 5px; border: 1px solid gray; "
            "background-color: #f9f9f9; }"
        )
        self.update_tags_display()
        tags_layout.addWidget(self.current_tags_display)
        
        # Tags input
        tags_input_layout = QHBoxLayout()
        self.tags_input = QLineEdit()
        self.tags_input.setPlaceholderText("Add tags (comma-separated)")
        add_tags_button = QPushButton("Add Tags")
        add_tags_button.clicked.connect(self.add_tags)
        
        tags_input_layout.addWidget(self.tags_input)
        tags_input_layout.addWidget(add_tags_button)
        tags_layout.addLayout(tags_input_layout)
        
        # Clear tags button
        clear_tags_button = QPushButton("Clear All Tags")
        clear_tags_button.clicked.connect(self.clear_tags)
        tags_layout.addWidget(clear_tags_button)
        
        parent_layout.addWidget(tags_group)
    
    def update_tags_display(self):
        """Update the tags display"""
        if self.photo.tags:
            tags_text = ", ".join(self.photo.tags)
        else:
            tags_text = "No tags"
        self.current_tags_display.setText(tags_text)
    
    def add_tags(self):
        """Add tags from input field"""
        new_tags_text = self.tags_input.text().strip()
        if not new_tags_text:
            return
        
        # Parse comma-separated tags
        new_tags = [tag.strip() for tag in new_tags_text.split(",") if tag.strip()]
        
        # Add to existing tags (avoid duplicates)
        current_tags = set(self.photo.tags or [])
        for tag in new_tags:
            current_tags.add(tag)
        
        # Update photo tags
        self.photo.tags = sorted(list(current_tags))
        self.update_tags_display()
        
        # Clear input
        self.tags_input.clear()
    
    def clear_tags(self):
        """Clear all tags"""
        self.photo.tags = []
        self.update_tags_display()
    
    def load_photo_data(self):
        """Load photo preview - always try coldpreview first, fallback to hotpreview"""
        # Always try coldpreview first - it will automatically fallback to hotpreview if not available
        self.load_preview('coldpreview')
    
    def load_preview(self, preview_type='coldpreview'):
        """Load photo preview (coldpreview or hotpreview)"""
        if preview_type == 'coldpreview':
            self.preview_status_label.setText("Loading preview...")
        else:
            self.preview_status_label.setText("Loading thumbnail...")
        
        # Store which preview type we're loading
        self.current_preview_type = preview_type
        
        # Start worker thread to load preview
        self.load_worker = ThumbnailLoadWorker(self.api_client, self.photo.hothash, preview_type)
        self.load_worker.thumbnail_loaded.connect(self.on_thumbnail_loaded)
        self.load_worker.error_occurred.connect(lambda msg: self.on_preview_error(msg, preview_type))
        self.load_worker.start()
    
    def on_preview_error(self, error_message, preview_type):
        """Handle preview load error - fallback if needed"""
        if preview_type == 'coldpreview':
            # Coldpreview failed - try hotpreview
            if ("404" in error_message or 
                "500" in error_message or 
                "Coldpreview not found" in error_message or
                "Internal Server Error" in error_message):
                self.preview_status_label.setText("Coldpreview not available - loading thumbnail...")
                self.load_preview('hotpreview')
            else:
                self.on_thumbnail_error(error_message)
        else:
            self.on_thumbnail_error(error_message)
    
    def on_thumbnail_loaded(self, image_data):
        """Handle preview image loaded"""
        pixmap = QPixmap()
        if pixmap.loadFromData(image_data):
            # Store original pixmap for zooming
            self.original_pixmap = pixmap
            self.zoom_level = 1.0
            
            # Display at fit-to-window size initially
            self.display_preview()
            
            # Get file size info
            size_kb = len(image_data) / 1024
            if size_kb < 1024:
                size_str = f"{size_kb:.1f} KB"
            else:
                size_str = f"{size_kb/1024:.1f} MB"
            
            # Show which type of preview was loaded
            preview_name = "Coldpreview" if self.current_preview_type == 'coldpreview' else "Thumbnail"
            self.preview_status_label.setText(f"{preview_name} loaded ‚Ä¢ {pixmap.width()}√ó{pixmap.height()}px ‚Ä¢ {size_str}")
        else:
            self.thumbnail_label.setText("Failed to load preview")
            self.preview_status_label.setText("Failed to decode image data")
    
    def on_thumbnail_error(self, error_message):
        """Handle preview load error"""
        self.thumbnail_label.setText(f"Preview error: {error_message}")
        self.preview_status_label.setText(f"Error: {error_message}")
    
    def display_preview(self):
        """Display the preview at current zoom level"""
        if not self.original_pixmap:
            return
        
        # Get available space
        available_width = self.thumbnail_label.width() - 20
        available_height = self.thumbnail_label.height() - 20
        
        if available_width <= 0 or available_height <= 0:
            available_width = 400
            available_height = 400
        
        # Calculate scaled size based on zoom level
        if self.zoom_level == 1.0:
            # Fit to window
            scaled_pixmap = self.original_pixmap.scaled(
                available_width, available_height,
                Qt.KeepAspectRatio, Qt.SmoothTransformation
            )
        else:
            # Apply zoom level
            target_width = int(self.original_pixmap.width() * self.zoom_level)
            target_height = int(self.original_pixmap.height() * self.zoom_level)
            scaled_pixmap = self.original_pixmap.scaled(
                target_width, target_height,
                Qt.KeepAspectRatio, Qt.SmoothTransformation
            )
        
        self.thumbnail_label.setPixmap(scaled_pixmap)
        self.thumbnail_pixmap = scaled_pixmap
        self.zoom_label.setText(f"{int(self.zoom_level * 100)}%")
    
    def zoom_in(self):
        """Zoom in by 25%"""
        if self.original_pixmap:
            self.zoom_level = min(self.zoom_level * 1.25, 5.0)  # Max 500%
            self.display_preview()
    
    def zoom_out(self):
        """Zoom out by 25%"""
        if self.original_pixmap:
            self.zoom_level = max(self.zoom_level * 0.8, 0.1)  # Min 10%
            self.display_preview()
    
    def zoom_reset(self):
        """Reset zoom to fit window"""
        if self.original_pixmap:
            self.zoom_level = 1.0
            self.display_preview()
    
    def save_changes(self):
        """Save changes to the photo"""
        # Prepare update request
        update_data = PhotoUpdateRequest(
            title=self.title_input.text().strip() or None,
            description=self.description_input.toPlainText().strip() or None,
            rating=self.rating_input.value() if self.rating_input.value() > 0 else None,
            location=self.location_input.text().strip() or None,
            tags=self.photo.tags if self.photo.tags else None
        )
        
        try:
            # Update photo via API
            updated_photo = self.api_client.update_photo(self.photo.hothash, update_data)
            
            # Update local photo object
            self.photo = updated_photo
            
            QMessageBox.information(self, "Success", "Photo updated successfully!")
            self.accept()
            
        except Exception as e:
            QMessageBox.critical(
                self, "Error",
                f"Failed to update photo:\n{str(e)}"
            )


class ThumbnailLoadWorker(QThread):
    """Worker thread for loading photo thumbnail or coldpreview"""
    thumbnail_loaded = Signal(bytes)
    error_occurred = Signal(str)
    
    def __init__(self, api_client, hothash, preview_type='hotpreview'):
        super().__init__()
        self.api_client = api_client
        self.hothash = hothash
        self.preview_type = preview_type  # 'hotpreview' or 'coldpreview'
    
    def run(self):
        try:
            if self.preview_type == 'coldpreview':
                # Load coldpreview with size appropriate for detail view (800px)
                thumbnail_data = self.api_client.get_photo_coldpreview(
                    self.hothash, width=800, height=600
                )
            else:
                # Load hotpreview (150x150 thumbnail)
                thumbnail_data = self.api_client.get_photo_thumbnail(self.hothash)
            
            self.thumbnail_loaded.emit(thumbnail_data)
        except Exception as e:
            # Enhanced error handling for better user experience
            error_str = str(e)
            if self.preview_type == 'coldpreview':
                # For coldpreview, provide more context about common issues
                if "500" in error_str or "404" in error_str:
                    error_str = f"Coldpreview not available (server returned {error_str})"
            self.error_occurred.emit(error_str)